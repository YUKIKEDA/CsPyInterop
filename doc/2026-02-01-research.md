# Pythonモジュールの他言語からの利用（相互運用）調査

## 1. 要件の整理

| 要件 | 説明 |
|------|------|
| **リバースエンジニアリング対策** | 配布するPythonスクリプトをバイナリ化または難読化し、ソース・ロジックの復元を困難にする |
| **Python未インストール環境で動作** | ユーザー環境にPythonが入っていなくても動作する（ランタイムを同梱するか、ネイティブ実行形式にする） |
| **追加インストール不要** | ユーザー側で pip やライブラリのインストール・インターネット接続が不要（依存はすべてビルド成果物に含める） |

---

## 2. 相互運用の方式の分類

他言語（C# を主に想定）から Python を利用する方法は、おおまかに次のように分けられる。

| 方式 | 概要 | 代表例 |
|------|------|--------|
| **同一プロセス（埋め込み）** | アプリ内でCPythonを初期化し、Pythonコードを直接実行 | Python.NET (pythonnet)、CSnakes |
| **別プロセス（起動）** | Pythonをコンパイルした実行ファイル（.exe）を子プロセスとして起動し、入出力で通信 | Nuitka/PyInstaller で作成した exe を Process.Start で呼び出し |
| **純粋 .NET 実装** | Python を .NET 上で動かす（CPython 不要） | IronPython |

---

## 3. Python のバイナリ化・難読化

配布物からソースを復元されにくくするための主な手段。

### 3.1 各方式の比較

| 方式 | 保護の強さ | 概要・注意点 |
|------|------------|--------------|
| **PyInstaller（単体）** | △ 弱い | .pyc を exe に同梱するだけ。pyinstxtractor + uncompyle6 等でバイトコード抽出・逆コンパイルが容易。`--key` で暗号化しても鍵が exe に含まれるため根本的には防げない。 |
| **Cython** | ○ 強い | .py → C → ネイティブ拡張（.pyd / .so）。逆コンパイルで元の Python には戻せない。エントリ用の .py が残る場合はそこだけ保護が弱い。 |
| **Nuitka（無償）** | ○ 強い | Python を C にコンパイルし exe/バイナリ化。ソースは残らず、文字列・定数も機械語レベルになる。**ただし 1 回のビルドに数十分〜数時間かかるため、実用上はビルド時間がネックになりやすい。** |
| **Nuitka Commercial** | ◎ より強い | 定数・鍵の難読化、トレースバックの暗号化、DLL 差し替え対策など、追加の保護機能あり。 |
| **難読化ツール（pyarmor 等）** | △〜○ | バイトコードの難読化・暗号化。ツール次第で強度は変わるが、ランタイムで復号する以上、完全な防御にはならない。 |

**結論（保護の観点）**: 配布するロジックを守りたい場合は、**Cython で .pyd/.so にコンパイル**する方式が、ビルド時間を考えると現実的。Nuitka は保護は強いがビルドが重い。PyInstaller の .pyc のみに頼るのは避けた方がよい。

---

## 4. 「Python 未インストール」を満たす方法

ユーザー環境に Python を入れずに動かす主なパターン。

| 方法 | 概要 |
|------|------|
| **Nuitka / PyInstaller のスタンドアロン** | `--mode=standalone` または `--onefile` で、Python ランタイムと依存をすべて exe（または exe+フォルダ）に含める。実行時にシステムの Python は不要。 |
| **埋め込み用 Python の同梱** | Windows の「embeddable package」や Python Standalone Builds など、最小構成の Python をアプリと一緒に配布し、pythonnet 等からそのパスを指定して使う。 |
| **PyOxidizer / PyOxy** | Python を単一実行ファイルに埋め込み。Rust ベースで、スタンドアロンな 1 ファイル配布に適する。 |
| **IronPython** | CPython は不要。.NET 上で Python が動く。その代わり、C 拡張に依存する NumPy 等のサードパーティは使えない／別対応が必要。 |

**結論**: 「ユーザーに Python を入れさせない」だけなら、**Nuitka/PyInstaller で exe 化**するか、**埋め込み用 Python を同梱して pythonnet で参照**するかのどちらかが現実的。

---

## 5. 「追加インストール不要」を満たす方法

| 方法 | 概要 |
|------|------|
| **Nuitka / PyInstaller** | ビルド時に必要なパッケージをすべて取り込み、配布物に含める。ユーザーは pip 不要。 |
| **埋め込み Python + ベンダリング** | embeddable に、必要な .whl や site-packages を事前に組み込み、アプリと一緒に配布する。pip はビルド時のみ使用。 |
| **IronPython** | 利用するライブラリをアプリ配布物に含めておけば、ユーザー側のインストールは不要（ただし CPython 用パッケージは使えない）。 |

**結論**: 依存ライブラリはすべて**ビルド／パッケージング時に解決し、成果物に同梱**する前提にすれば、ユーザー環境では追加インストールもインターネットも不要にできる。

---

## 6. 呼び出し方式ごとの整理

### 6.1 同一プロセス（Python 埋め込み）

- **Python.NET (pythonnet)**  
  - CPython を .NET から初期化し、`PyModule.Import()` 等で Python モジュールを呼び出す。  
  - **Python 未インストール**にするには、Windows Embeddable Package 等をアプリに同梱し、`Runtime.PythonDLL` でその python3.dll を指す必要がある。  
  - サードパーティはビルド時に site-packages を同梱すれば、ユーザーは何もインストールしないでよい。

- **CSnakes**  
  - .NET 8/9 向け。Source Generators で Python を埋め込み、型情報から C# のメソッドを生成。  
  - こちらも実行時には CPython ランタイム（同梱 or システム）が必要。

- **保護**  
  - 埋め込みの場合は「実行するのが .py / .pyc か、.pyd か」で変わる。  
  - 保護を強くするなら、呼び出すモジュールを **Cython で .pyd 化**してから、その .pyd を同梱して pythonnet で import する構成が有効。

### 6.2 別プロセス（実行ファイルの起動）

- **流れ（exe 化する場合）**  
  1. Nuitka または PyInstaller で、Python プログラムを「スタンドアロン exe」にビルド（依存も同梱）。  
  2. C# から `Process.Start` でその exe を起動。  
  3. 引数・stdin/stdout（または名前付きパイプ等）でデータをやり取り。  
  → **ただし Nuitka/PyInstaller は 1 回のビルドに数十分〜数時間かかるため、実用上は採用しない**（本ドキュメント §7, §8 を参照）。

- **流れ（組み込み Python + Cython の場合）**  
  1. 自前ロジックを Cython で .pyd 化し、組み込み Python と site-packages を同梱。  
  2. 起動用の短い .py（例: 1 行で .pyd を import して main を呼ぶ）を同梱の `python.exe` に渡す。  
  3. C# から `Process.Start` でその `python.exe` を起動し、引数・stdin/stdout 等で通信。  
  → ロジックは .pyd にあり、.py は最小限なので実用的（§8 推奨方針）。

- **注意**  
  - `--windows-disable-console` や `--noconsole` を使うと、子プロセスの stdout/stderr を C# で取りにくい場合がある。IPC が必要なら、コンソールありで起動するか、名前付きパイプ等を検討する。

### 6.3 IronPython（.NET 上の Python）

- **特徴**  
  - CPython は不要。.NET の DLL として配布すれば、ユーザーは Python をインストールしない。  
  - サードパーティは「IronPython 用にビルドされたもの」か、純粋 Python のみが前提。NumPy 等の C 拡張はそのままでは使えない。  
  - 配布物にライブラリを同梱すれば、ユーザー側の追加インストールは不要。

- **保護**  
  - 実行は .NET 上なので、.py を難読化するか、別途 Nuitka 等でコンパイルしたモジュールを IronPython から呼ぶような構成は一般的ではない。IronPython で「ロジックを隠す」場合は、難読化や別アセンブリに分離するなどの工夫になる。

---

## 7. 実用上の制約と却下した選択肢

要件は満たしつつ、以下は実用性・要望の理由で採用しないものとする。

| 選択肢 | 却下理由 |
|--------|----------|
| **Nuitka / PyInstaller / cx_Freeze** | 1 回のビルドに数十分〜数時間かかり、開発サイクルや CI で現実的でない。 |
| **C/C++ での再実装** | NumPy や機械学習ライブラリなど、Python の数値計算・ML 系ライブラリをそのまま使いたいため不可。 |
| **Python サーバー（別プロセスで常駐）** | 配布形態やオフライン前提の要件に沿わない。 |

**組み込み Python（embeddable package）を配布物に同梱**すれば、エンドユーザーが Python を別途インストールする必要はない。サブプロセスで `python.exe` を起動する形でも、同梱したランタイムを指せばよい。そのうえで、**.py のリバースエンジニアリング対策**としてソースを配布しない必要がある。

---

## 8. 推奨方針: Cython + 組み込み Python

上記の制約を踏まえると、**Cython でロジックを .pyd 化し、組み込み Python を同梱する**構成が現実的である。

### 8.1 この組み合わせを選ぶ理由

- **ビルド時間**: Cython はモジュール単位のコンパイル（.py → C → .pyd）であり、Nuitka/PyInstaller のような「アプリ全体＋依存を 1 本に固める」処理と比べて桁違いに短い。変更のあったモジュールだけ再ビルドすればよい。
- **保護**: 本質的なロジックは .pyd に含まれるため、.py を配布せずにリバースエンジニアリングを抑えられる。
- **Python 未インストール**: Windows Embeddable Package（または Python Standalone Builds）をアプリに同梱し、その `python.exe` / `python3.dll` だけを使う。
- **追加インストール不要**: NumPy 等の依存はビルド時に wheel で取得し、同梱した Python の site-packages に含めて配布する。
- **数値計算・ML ライブラリ**: CPython のネイティブ拡張（NumPy 等）をそのまま利用できる。Cython でコンパイルするのは「自前の .py ロジック」だけでよい。

### 8.2 呼び出し方の二通り

**同一プロセス（埋め込み・推奨）**

1. 自前ロジックを **Cython で .pyd にコンパイル**。  
2. **組み込み Python** と、必要な site-packages（NumPy 等）をビルド時に用意し、配布物に同梱。  
3. C# から **pythonnet** で同梱 Python の `python3.dll` を指定して初期化し、`PyModule.Import()` で .pyd を import して利用。

- 配布する .py は原則不要（エントリも .pyd に含めるか、ごく短いブート用 1 行だけにすればよい）。

**サブプロセス**

1. 同上で自前ロジックを .pyd 化し、組み込み Python と site-packages を同梱。  
2. 起動用に **ごく短い .py**（例: `import my_compiled_module; my_compiled_module.main()` の 1 行）だけを用意し、同梱の `python.exe` にこの .py を渡す。  
3. C# からは `Process.Start` でその `python.exe` を起動し、引数・stdin/stdout（または名前付きパイプ）で通信。

- 価値のあるロジックはすべて .pyd 側にあり、.py は「どの .pyd を起動するか」だけなので、リバースエンジニアリングのリスクは小さい。

### 8.3 まとめ

| 項目 | 方針 |
|------|------|
| リバースエンジニアリング対策 | 自前コードは **Cython で .pyd 化**し、.py は配布しない（またはエントリの 1 行のみ）。 |
| Python 未インストールで動作 | **組み込み Python を配布物に同梱**し、そのランタイムのみを使用。 |
| 追加インストール不要 | 依存は **ビルド時に解決し、同梱 Python の site-packages に含めて配布**。 |
| 呼び出し方 | **同一プロセス（pythonnet）** または **サブプロセス（同梱 python.exe の起動）** のどちらでも可。 |

**結論**: 実用上の制約（ビルド時間・数値計算/ML ライブラリ利用・サーバー却下）を満たすなら、**Cython + 組み込み Python** が適している。

### 8.4 利用イメージ

#### 配布物のディレクトリ構成（例）

エンドユーザーに渡すフォルダのイメージ。C# アプリと同梱 Python・コンパイル済み .pyd を一括で配布する。

```
MyApp/
├── MyApp.exe                    # C# でビルドしたメインアプリ
├── MyApp.dll
├── Python.Runtime.dll           # pythonnet
├── python/                      # 同梱した組み込み Python
│   ├── python.exe               # サブプロセス用（同一プロセスでは不要だが同梱しておいてもよい）
│   ├── python311.dll
│   ├── python311.zip
│   ├── Lib/
│   │   └── site-packages/       # NumPy 等の依存（ビルド時に詰め込んだもの）
│   │       ├── numpy/
│   │       ├── my_compiled_module.pyd   # Cython でビルドした自前モジュール
│   │       └── ...
│   └── ...
└── (サブプロセス用の場合のみ) run.py   # 1 行: import my_compiled_module; my_compiled_module.main()
```

- **同一プロセス（pythonnet）** のみなら `python.exe` と `run.py` は不要。C# が直接 `python311.dll` をロードし、`site-packages` 内の .pyd を import する。
- **サブプロセス** の場合は、C# が `python/python.exe run.py ...` のように起動し、`run.py` が .pyd を import して処理する。

---

#### 同一プロセス（pythonnet）での利用フロー

1. C# アプリ起動。
2. 同梱 Python の DLL パスを指定して pythonnet を初期化。
3. GIL を取得し、`PyModule.Import("my_compiled_module")` で .pyd を import。
4. 取得したモジュールの関数を呼び出し、引数は C# から Python オブジェクトに変換して渡す。戻り値は Python から C# に変換して受け取る。
5. 処理後、必要に応じて Python エンジンをシャットダウン（アプリ終了時など）。

**C# 側のイメージ（擬似コード）**

```csharp
using Python.Runtime;

// 同梱 Python のパスを設定（アプリ基準の相対パスなど）
string appDir = AppContext.BaseDirectory;
string pythonHome = Path.Combine(appDir, "python");
Environment.SetEnvironmentVariable("PYTHONHOME", pythonHome, EnvironmentVariableTarget.Process);
Runtime.PythonDLL = Path.Combine(pythonHome, "python311.dll");  // バージョンに合わせる

PythonEngine.Initialize();
using (Py.GIL())
{
    dynamic sys = Py.Import("sys");
    sys.path.append(Path.Combine(pythonHome, "Lib", "site-packages"));

    PyObject module = Py.Import("my_compiled_module");   // .pyd を import
    PyObject result = module.InvokeMethod("compute", new PyObject[] { arg1.ToPython(), arg2.ToPython() });

    // 戻り値を C# で利用
    double value = result.AsManagedObject(typeof(double));
}
PythonEngine.Shutdown();
```

**Python 側（Cython でコンパイルする前の .py のイメージ）**

```python
# my_compiled_module.py （ビルド後は .pyd のみ配布）
import numpy as np

def compute(x, y):
    # NumPy 等を使った計算
    arr = np.array([x, y])
    return float(np.sum(arr))
```

- エンドユーザーには **.pyd だけ** が渡り、この .py は渡さない。

---

#### サブプロセスでの利用フロー

1. C# アプリが、同梱の `python/python.exe` に対して `run.py` と引数を渡して `Process.Start`。
2. `run.py` は「`my_compiled_module` を import して `main()` を呼ぶ」だけの 1 行（または数行）。
3. .pyd 内の `main()` が、stdin / 引数 / 環境変数などから入力を受け取り、計算後に stdout やファイルに結果を出す。
4. C# は子プロセスの標準出力を読み取る、または出力ファイルを読むなどして結果を取得。

**起動用 run.py（配布する唯一の .py・中身は最小限）**

```python
# run.py
import my_compiled_module
my_compiled_module.main()
```

**C# 側のイメージ（擬似コード）**

```csharp
var pythonExe = Path.Combine(appDir, "python", "python.exe");
var runScript = Path.Combine(appDir, "run.py");
var startInfo = new ProcessStartInfo
{
    FileName = pythonExe,
    Arguments = $"\"{runScript}\" --input \"{inputPath}\" --output \"{outputPath}\"",
    UseShellExecute = false,
    RedirectStandardOutput = true,
    RedirectStandardError = true,
};
using var process = Process.Start(startInfo);
string stdout = process.StandardOutput.ReadToEnd();
string stderr = process.StandardError.ReadToEnd();
process.WaitForExit();
// stdout / 出力ファイルから結果を取得
```

**Python 側（.pyd の元になる .py のイメージ）**

```python
# my_compiled_module.py → Cython で .pyd にビルド
import sys
import numpy as np

def main():
    # コマンドライン引数や stdin から入力を受け取り、
    # 計算結果を stdout やファイルに書き出す
    args = parse_args(sys.argv)
    result = do_compute(args)
    print(result)  # C# は StandardOutput で受け取る
```

- ロジックはすべて **my_compiled_module.pyd** にあり、`run.py` は「どの .pyd を起動するか」だけなので、リバースエンジニアリングの対象は小さい。

---

#### データの受け渡しの整理

| 呼び出し方 | 入力の渡し方 | 結果の受け取り方 |
|------------|--------------|------------------|
| **同一プロセス（pythonnet）** | C# のオブジェクトを `ToPython()` で PyObject 化し、Python の関数の引数として渡す。 | Python の戻り値を `.AsManagedObject()` や `.ToString()` などで C# 型に変換。 |
| **サブプロセス** | コマンドライン引数、環境変数、stdin、または入力用ファイルパスを渡す。 | 子プロセスの stdout を読み取る、または出力用ファイルを指定してその内容を読む。 |

- 同一プロセスなら **オブジェクトをそのまま渡せる** ため、複雑なデータ構造や頻繁な呼び出しに向く。
- サブプロセスは **プロセス間の境界** があるため、テキストや JSON・ファイルパスなど、シリアライズしやすい形で渡すと扱いやすい。

---

## 9. 技術・ツールの参照まとめ

| 項目 | 主な技術・ツール |
|------|------------------|
| C# から Python 呼び出し（埋め込み） | Python.NET (pythonnet), CSnakes |
| C# から Python 呼び出し（プロセス） | Process.Start + stdin/stdout または名前付きパイプ |
| Python なしで動かす | Nuitka, PyInstaller, Windows Embeddable Package, Python Standalone Builds, PyOxidizer |
| バイナリ化・保護 | Nuitka, Cython, Nuitka Commercial |
| 配布・パッケージング | Nuitka (--onefile/--standalone), PyInstaller, embeddable + ベンダリング |

---

## 10. 参考文献・リンク

- Python.NET: https://pythonnet.github.io/pythonnet/
- Nuitka: https://nuitka.net/
- PyInstaller: https://pyinstaller.org/
- Cython: https://cython.org/
- Windows Embeddable Package: https://devblogs.microsoft.com/python/cpython-embeddable-zip-file/
- Python Standalone Builds: https://gregoryszorc.com/docs/python-build-standalone/main/
- PyOxidizer: https://pyoxidizer.readthedocs.io/
- IronPython: https://ironpython.net/
